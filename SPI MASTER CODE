#include <SPI.h>

static const int PIN_SCK  = 18;
static const int PIN_MISO = 19;
static const int PIN_MOSI = 23;
static const int PIN_CS   = 5;

static const uint32_t POLL_MS = 20;

static const uint8_t  PAYLOAD_MAX = 32;
static const uint8_t  FRAME_SIZE  = 2 + PAYLOAD_MAX; // flags + len + payload

SPIClass spi(VSPI);

// Outgoing message (one-slot mailbox)
volatile bool outHasMsg = false;
uint8_t outLen = 0;
char outBuf[PAYLOAD_MAX + 1]; // +1 for '\0' locally

// Serial line assembly buffer
String lineBuf;

void spiExchange(uint8_t* tx, uint8_t* rx, size_t n) {
  digitalWrite(PIN_CS, LOW);
  spi.transferBytes(tx, rx, n);
  digitalWrite(PIN_CS, HIGH);
}

void setup() {
  Serial.begin(115200);
  delay(200);

  pinMode(PIN_CS, OUTPUT);
  digitalWrite(PIN_CS, HIGH);

  spi.begin(PIN_SCK, PIN_MISO, PIN_MOSI, PIN_CS);
  spi.beginTransaction(SPISettings(1000000, MSBFIRST, SPI_MODE0));

  Serial.println("ESP32 SPI MASTER (words, polling, 4-wire).");
  Serial.println("Type a line and press Enter to send to SLAVE.");
}

void queueOutgoingLine(const String& s) {
  // copy up to 32 bytes
  outLen = (uint8_t)min((int)PAYLOAD_MAX, (int)s.length());
  for (uint8_t i = 0; i < outLen; i++) outBuf[i] = s[i];
  outBuf[outLen] = '\0';
  outHasMsg = true;

  Serial.print("Queued SEND -> SLAVE: ");
  Serial.println(outBuf);
}

void loop() {
  // Read serial into a line (ignore CR)
  while (Serial.available()) {
    char c = (char)Serial.read();
    if (c == '\r') continue;

    if (c == '\n') {
      if (lineBuf.length() > 0) {
        queueOutgoingLine(lineBuf);
        lineBuf = "";
      }
    } else {
      if (lineBuf.length() < 200) lineBuf += c; // just prevent huge lines
    }
  }

  static uint32_t lastPoll = 0;
  uint32_t now = millis();
  if (now - lastPoll < POLL_MS) return;
  lastPoll = now;

  uint8_t tx[FRAME_SIZE] = {0};
  uint8_t rx[FRAME_SIZE] = {0};

  // Build TX frame
  if (outHasMsg) {
    tx[0] = 0x01;           // flags: message valid
    tx[1] = outLen;         // length
    memcpy(&tx[2], outBuf, outLen);
  } else {
    tx[0] = 0x00;
    tx[1] = 0x00;
  }

  // Exchange
  spiExchange(tx, rx, FRAME_SIZE);

  // If we just transmitted our message once, clear it
  if (outHasMsg) {
    outHasMsg = false;
    Serial.print("SENT -> SLAVE: ");
    Serial.println(outBuf);
  }

  // Decode RX frame from slave
  uint8_t inFlags = rx[0];
  uint8_t inLen   = rx[1];

  if ((inFlags & 0x01) && inLen > 0 && inLen <= PAYLOAD_MAX) {
    char msg[PAYLOAD_MAX + 1];
    memcpy(msg, &rx[2], inLen);
    msg[inLen] = '\0';

    Serial.print("RECEIVED <- SLAVE: ");
    Serial.println(msg);
  }
}
